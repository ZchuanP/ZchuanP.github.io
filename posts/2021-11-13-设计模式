---
title: 常见设计模式总结
date: 2021-11-13 HH:MM:SS +/-TTTT
categories: [设计模式]
tags: [设计模式]     # TAG names should always be lowercase
---

# Head First 设计模式

## 总纲：设计原则

+ 设计原则1：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。（**封装变化**）
+ 设计原则2：针对接口（针对超类型）编程，而不是针对实现编程。
+ 设计原则3：多用组合，少用继承。
+ 设计原则4：为了交互对象之间的松耦合设计而努力。
+ 设计原则5：类应该对扩展开放，对修改关闭。（开闭原则）
+ 设计原则6：要依赖抽象，不要依赖具体类。（依赖倒置原则）
+ 设计原则7：只和你的密友（最需要的几个对象）谈话（最少知识原则：不要让太多类耦合在一起）
+ 设计原则8：别调用我们，我们会调用你。（好莱坞原则，防止“依赖腐败”：允许低层组件将自己挂钩到系统上，高层组件会决定什么时候和怎样使用低层组件）
+ 设计原则9：一个类应该只有一个引起变化的原因（单一责任原则）

## 设计模式总结

> **类图都是每个模式理解的重点对象。**

### 1.  策略模式

**定义**：策略模式定义了**算法族**，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。

**特点**：将变化的部分**抽象为接口**，不同种类的该部分可为不同的实现类。主类可自由选择（通过组合选择）需要的实现类。

**解释**：将代码中会变化的部分(需求可能变更，技术可能更新)取出来并封装起来，以便以后可以轻易的改变或扩充此部分，而不影响其它不需要变化的部分。

**举例**：duck类不同的鸭子有不同的叫声和飞行方式，我们可以将叫声和飞行方式单独封装起来。不同种类的duck继承不同的叫声和飞行方式的类。

> 例子代码：D:/ideaku/headfirst/Strategy

在这里,我们将鸭子的叫声/飞行看着一族算法。在有些应用场景下，需要不同的算法实现同一个功能（某些场景对事件效率要求高，有的则是空间）也可以使用策略模式。

---

### 2. 观察者模式

**定义**：观察者模式定义了对象之间的一（被观察者/主题）对多（观察者）依赖，这样依赖，当一个对象状态改变时，它的所有依赖者都会**收到通知并自动更新**。

**特点**：观察者可调用被观察者的方法注册和删除观察者，被观察者可调用观察者的方法更新数据。   |   在观察者模式中，**被观察者和观察者是松耦合的**。主题只知道观察者实现了某个接口，而不需要关心观察的具体类是什么，做了些什么和其它细节。我们可以在任何时候增加新的观察者而不会对被观察者造成影响。（我们可以独立的复用观察者和被观察者，改变其中任意一方都不会影响另一方）

**松耦合将对象间的依赖降至最低**

**观察者模式类图：**

![image-20211008173246141](C:\Users\14262\AppData\Roaming\Typora\typora-user-images\image-20211008173246141.png)

**观察者模式对设计原则的体现：**

+ 设计原则1： 在观察者模式中，会改变的是被观察者的状态，已经观察者的数目和类型。观察者模式中可以改变观察者的状态，却不必改变被观察者。
+ 设计原则2：被观察者和观察者均使用接口，观察者使用被观察者的接口向被观察者注册与删除，被观察者利用观察者接口通知观察者。
+ 设计原则3：观察者模式利用组合将许多观察者组合进主题中。对象之间的这种关系不是通过继承产生的，而是在运行时利用组合的方式产生的。

---

### 3. 装饰者模式

**定义**：装饰者模式动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

**特点**：

类似于一种叠加，传入原来的对象引用初始化新的装饰者对象，将被装饰者的特性叠加在装饰者上。如下例子：

```java
package headfirst.designpatterns.decorator.starbuzz;

public class StarbuzzCoffee {
 
	public static void main(String args[]) {
		Beverage beverage = new Espresso();
		System.out.println(beverage.getDescription() 
				+ " $" + beverage.cost());
 
		Beverage beverage2 = new DarkRoast();
		beverage2 = new Mocha(beverage2);
		beverage2 = new Mocha(beverage2);
		beverage2 = new Whip(beverage2);
		System.out.println(beverage2.getDescription() 
				+ " $" + beverage2.cost());
 
		Beverage beverage3 = new HouseBlend();
		beverage3 = new Soy(beverage3);
		beverage3 = new Mocha(beverage3);
		beverage3 = new Whip(beverage3);
		System.out.println(beverage3.getDescription() 
				+ " $" + beverage3.cost());
	}
}
```

+ **装饰者和被装饰对象有着相同的超类型**，在任何需要原始对象的场合，可以用装饰过的对象替代它。（装饰的前提）
+ 可以用一个或多个装饰者包装一个对象
+ 装饰者可以在所委托或被装饰者的行为之前/之后，加上自己的行为，以达到特定的目的。
+ 对象可以在任何时候被装饰，所以可以在运行时动态地，不限量地用你喜欢的装饰者来装饰对象。

装饰者模式类图：

![image-20211008204956940](C:\Users\14262\AppData\Roaming\Typora\typora-user-images\image-20211008204956940.png)

----

### 4. 工厂模式

**简单工厂**：将对象的创建操作封装到了一个单独的类中，这个类即是工厂类。

**解析**：将不同对象的创建操作进行了一层简单的封装，只是将不同对象的创建操作全部放到了一个类中，这个类就是简单工厂。简单工厂可以降低系统的耦合性，但是违背了**设计原则5：开闭原则**，当新增产品时必须修改工厂类。所以简单工厂并不能称为一个设计模式，而更像一种良好的编程习惯。

![image-20211009165400691](C:\Users\14262\AppData\Roaming\Typora\typora-user-images\image-20211009165400691.png)

**工厂方法模式**：工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到了子类。

**解析：**将对象分类后，在工厂类下按照分类建立子工厂类，我们需要的类都是由子工厂类的工厂方法来创建。新增产品时增加对应的工厂和产品，符合了**开闭原则**。同时每个工厂负责**一种产品**，符合**单一职责原则**。但当新增产品时，系统中类的个数会成倍增长，增加了系统复杂性。

![image-20211009170542159](C:\Users\14262\AppData\Roaming\Typora\typora-user-images\image-20211009170542159.png)

**抽象工厂模式**：抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

解析：抽象工厂提供一个用来创建**一个产品族**的抽象类型，这个类型的子类定义了产品被产生的方法。每个具体工厂都能产生一整组的产品。

![image-20211009173711213](C:\Users\14262\AppData\Roaming\Typora\typora-user-images\image-20211009173711213.png)

工厂方法模式和抽象工厂模式区别：

+ 工厂方法和抽象工厂都是用来创建对象的。工厂方法使用的方法为继承，抽象工厂模式使用的方法是对象的组合。
+ 抽象工厂模式的优点是能**将一群相关产品集合起来**（像书中提到的原料产品）。但是扩展必须改变接口（工厂方法只需要新的子类）。
+ 抽象工厂模式经常使用工厂方法实现具体的工厂。

----

### 5. 单例模式

**定义**：单例模式确保一个类只有一个实例，并提供一个全局访问点。

**目的**：保证一个对象只能被实例化一次。(线程池、注册表设置、缓存、对话框、日志对象)；**想要取得单例实例，通过单例类是唯一的途径。**

**作用**：确保程序中使用的全局资源只有一份，常常被用来管理共享的资源。

**做法**：为了保证只能被实例化一次，我们将类构造方法申明为private方法（无法用new创建类），但因为我们没有类实例调用该构造方法，所以将该构造方法声明为static方法（不需要类实例，类名即可调用）。，我们声明一个类引用（记录是否存在类实例），我们可以在单例类中声明一个根据类引用状态获取类的public方法（可控）。

```java
/*
 * 单例模式简单示例：下面代码有一些问题
 */
 public class Person{
 		private static Person onlyPerson = null;
    /* other 属性
    */
   	private Person(){};
 		public static Person getInstance(){
      	if(onlyPerson == null){
        		onlyPerson = new Person();
      	}
      	return onlyPerson;
    }
   
    /* other 方法
      */
 }
/* 问题解析：
	 当使用多线程时，试想有两个线程同时执行getInstance方法。
	 同时进行if判断，此时对于两个线程来说，onlyPerson均为null。所以两个线程会同时实例化出不同的Person对象。
	 */
```

```java
/* 解决方案1：同步方法
	 将getInstance方法变成同步（synchronized）方法,来确保不会有多个线程同时进入这个方法。
	 */
public class Person{
 		private static Person onlyPerson = null;
    /* other 属性
    */
   	private Person(){};
 		public static synchronized Person getInstance(){
      	if(onlyPerson == null){
        		onlyPerson = new Person();
      	}
      	return onlyPerson;
    }
   
    /* other 方法
      */
 }
/*方案1新的问题：
	 同步会降低性能，且只有第一次执行该方法的时候才需要同步。
	 之后的调用，同步都是一种累赘。
	 如果系统对性能需求不高可以采用这种方法。
	 */
```

```java
/*解决方案2：“急切”创建
	 private static Person onlyPerson = new Person;
	 依赖于在jvm首次加载该类时马上创建唯一的实例。jvm保证了在任何线程访问该静态变量前先创建实例。
	 */
public class Person{
 		private static Person onlyPerson = new Person();
    /* other 属性
    */
   	private Person(){};
 		public static synchronized Person getInstance(){
      	return onlyPerson;
    }
   
    /* other 方法
      */
 }
```

```java
 /* 解决方案3：“双重检测加锁”
	 首先检测实例是否已经创建，如果没有创建再进行同步。实现了第一次执行方法时同步以后不同步。
	 */
public class Person{
 		private volatile static Person onlyPerson = null;
    /* other 属性
    */
   	private Person(){};
 		public static Person getInstance(){
      	if(onlyPerson == null){
          	synchronized (Person.class){
              	if(onlyPerson == null) {
                  	onlyPerson = new Person();
                }
            }
        }
      	return onlyPerson;
    }
   
    /* other 方法
      */
 }
/* 注意点：
	 volatile关键字确保onlyPerson变量被初始化为Person实例时，多个线程正确的处理该变量。
	 该方法不适用于1.4版本及之前的java
*/
```

---

### 6. 命令模式

**定义**：命令模式**将"请求"封装成对象**，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。

**作用**：将方法调用封装起来。将“发出请求的对象”和“接受与执行这些请求的对象”分隔开来。

**角色&解析**：客户，命令对象，代理对象，接收对象：客户生成命令对象（包含可在接收对象中执行的一系列方法，命令对象有一个接收对象的属性）。交给代理对象（对象组合，代理对象有个命令对象的属性），代理对象可调用一个传送的方法在接收对象中调用命令对象中包含的方法。所以可以直接使用代理对象执行命令，实现客户和接收对象的解耦。

**命令模式类图**：

<img src="C:\Users\14262\AppData\Roaming\Typora\typora-user-images\image-20211011165623979.png" alt="image-20211011165623979" style="zoom:80%;" />

---

### 7. 适配器模式

**定义**：适配器模式将一个类的接口（被适配接口），转换成客户期望的另一个接口（目标接口）。适配器让原本不兼容的类可以合作无间。（让客户从实现的接口解耦，只用调用适配器不用关心目标接口的具体实现）

**解析**：一个软件系统，将要和一个新的厂商类库搭配使用，但是这个新厂商类的接口与旧接口不同。在不改变现有代码的情况下，我们可以通过适配器模式将新厂商提供的接口封装成旧厂商接口的形式。这个适配器类可以将客户发出的旧接口形式的请求转化为新厂商接口的形似。

**类图**：

![image-20211012163146950](C:\Users\14262\AppData\Roaming\Typora\typora-user-images\image-20211012163146950.png)

**类适配器**：类适配器通过继承被适配者和目标类来实现。需要支持多重继承的语言。上述的**对象适配器通过组合来实现**。它的优势在于通过继承实现可以不必将被适配者全部重新实现，但不如对象适配器有弹性（通过组合的方式可将适配器搭配被适配对象的子类使用）

### 8. 外观模式

**定义**：外观模式提供一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

**解析**：与适配者模式类似，都是改变接口。但外观模式改变接口的原因是**简化接口**。他将一个或数个类的复杂的一切丢隐藏起来，只显露出一个干净美好的外观。所以巧妙的称为“外观模式”。 在提供简化接口的同时，外观模式还将系统完整的功能暴露出来（没有封装）供需要的对象使用。同时也实现了将客户从组件的子系统中解耦。

![20211012172616628](C:\Users\14262\AppData\Roaming\Typora\typora-user-images\image-20211012172616628.png)

---

### 9. 模板方法模式

**定义**：模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法接口的情况下，重新定义算法中的某些步骤。

**解析**：模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。【提供了统一的控制逻辑（算法步骤），并尽可能消除了重复的代码，代码改变只需要改变超类 】

**类图**：

![image-20211012185334336](C:\Users\14262\AppData\Roaming\Typora\typora-user-images\image-20211012185334336.png)

**钩子（hook）**：钩子是一种声明在抽象类中的方法，但只有空的或者默认的实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。用途：

+ 能够作为条件控制，影响抽象类中的算法流程（算法流程在模板方法中固定的，可以通过子类实现钩子来影响）。

---

### 10. 迭代器模式

**定义**：迭代器模式提供了一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

**解析**：迭代器模式依赖于一个名为迭代器的接口。通过这个接口，可以为各种对象集合实现迭代器。迭代器封装了遍历。迭代器模式让我们遍历集合内的每一个元素，而不暴露其内部的表示。

**类图**：

![image-20211013161723184](C:\Users\14262\AppData\Roaming\Typora\typora-user-images\image-20211013161723184.png)

---

### 11. 组合模式

**定义**：组合模式允许你将对象组合成树形结构来表现“整体/部分”的层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。

**解析**：组合模式让我们能用树形的方式创建对象的结构，树里包含了组合以及个别的对象。使用组合结构，我们能把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别。

这种方式所有对象实现相同的接口，但是具有层级关系。可以用来划分组合且可通过递归进行访问。

![image-20211013165432463](C:\Users\14262\AppData\Roaming\Typora\typora-user-images\image-20211013165432463.png)

**设计原则**：同时包含管理子节点的操作和叶节点的操作，违背单一责任原则。组合模式用单一责任原则来换取透明性，同时包含这些操作可将组合和叶节点一视同仁，一个元素究竟是组合还是叶节点对客户都是透明的。

// 组合的封装需要复习：waiter类递归遍历  迭代器+组合模式

+++

### 12. 状态模式

**定义**：状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。

**解析**：当系统存在多个状态且会根据条件进行状态转换时，我们将所有状态下可能发生的行为抽象到接口中，将每一种状态作为一个类并实现对应的方法。**第一部分：**这样可以将我们的行为局部化到每个状态的类中，且容易改变和扩展。将状态封装成独立的类，并将动作委托到代表当前状态的对象（每个状态决定自己的行为）。**第二部分：**从客户角度来看，使用的对象能够随着状态的转换完全改变它的行为（就是是实例化了新的类一样）。

**类图**：

![image-20211015183839369](C:\Users\14262\AppData\Roaming\Typora\typora-user-images\image-20211015183839369.png)

**与策略模式的区别**：这两个模式的差别主要在于意图上的差别。

+ 状态模式中，将一群行为封装在状态对象中，Context的行为可以随时委托到这些状态对象中的一个来改变Context的行为。当前状态在状态对象中游走改变，反应了context的内部状态。
+ 对于策略模式来说，用户通常主动指定Context所要组合的策略对象是哪一个。虽然也可以改变，但通常都只有一个最适当的策略对象。

---

### 13. 代理模式

**定义**：代理模式为另一个对象提供一个替身（代表）以控制对这个对象的访问。

**解析**：代理，就是代表某个真实的对象。

**方式**：代理控制访问的几种常见方式：

+ **远程代理**控制访问远程对象。
+ **虚拟代理**控制访问创建开销大的资源。（直到我们真正需要这个对象的时候才创建它）
+ **保护代理**基于权限控制对资源的访问。

**类图**：

![image-20211018164016916](C:\Users\14262\AppData\Roaming\Typora\typora-user-images\image-20211018164016916.png)



---

### 14. 复合模式









